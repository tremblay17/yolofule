# -*- coding: utf-8 -*-
"""stockClassifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P09g_9Z6rTCvFz0egVLp6gEKMyHg9Z8e
"""

#https://www.projectpro.io/article/stock-price-prediction-using-machine-learning-project/571
#https://pypi.org/project/yfinance/
#https://stackoverflow.com/questions/51581521/accuracy-stuck-at-50-keras
#https://towardsdatascience.com/predicting-stock-prices-using-a-keras-lstm-model-4225457f0233
#https://machinelearningknowledge.ai/keras-lstm-layer-explained-for-beginners-with-example/
#https://www.kaggle.com/code/nizado/keras-for-stocks-prediction
!pip install yfinance
!pip install requests-cache
!pip install pandas
!pip install numpy
!pip install scikit-learn
!pip install tensorflow
!pip install keras
!pip install pandas_ta

import requests_cache
import yfinance as yf
import pandas_ta as ta

selection = 'AAPL AMD GOOGL NVDA'
data = yf.Ticker('AAPL').history(period='5y')[['Close', 'Open', 'High', 'Volume', 'Low']]

'''close='Close'
name='aapl'
data.ta.macd(close=close, fast=12, slow=26, signal=9, append=True)
data.ta.rsi(close=close, length=14, append=True)
data.ta.bias(close=close, append=True)
data.ta.adx(close=close, append=True)
data.ta.stdev(close=close, append=True)

data.to_csv(f"/content/data/{name}")'''

import pandas as pd
import numpy as np

np.set_printoptions(precision=3, suppress=True)

data = pd.read_csv('/content/sample_data/nvda')
data_inputs = data.iloc[:, 1:14].values
data_class = data.iloc[:, 15:16].values
print(data_class)

#Classes 'B_Small', 'B_large', or 'Sell' 
np.asarray(data_inputs).astype('float32')
np.asarray(data_class).astype('float32')

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, StandardScaler

x_train, x_test, y_train, y_test = train_test_split(data_inputs, data_class, train_size=0.75)

#Standardization
sc2 = StandardScaler()
sc2.fit(x_train)
sc2.transform(x_train)
sc2.transform(x_test)

#Normalization
sc = MinMaxScaler()
sc.fit(x_train)
sc.transform(x_train)
sc.transform(x_test)

import keras as k
from keras.models import *
from keras.layers import *

x_train = np.reshape(x_train, (x_train.shape[0], 1, x_train.shape[1]))
x_test = np.reshape(x_test, (x_test.shape[0], 1, x_test.shape[1]))
x_test.shape

seqModel = Sequential()
#seqModel.add(Reshape((13,1)))
#print(seqModel.output_shape)
#print(seqModel.input_shape)
#seqModel.add(Normalization(axis=None).adapt(data_input))

seqModel.add(InputLayer((1,13)))
seqModel.add(LSTM(units=48, return_sequences=True, dropout=0.2))
seqModel.add(LSTM(units=64, return_sequences=True, dropout=0.2))
seqModel.add(LSTM(units=96, return_sequences=True, dropout=0.2))
seqModel.add(LSTM(units=96, dropout=0.2))
seqModel.add(Dense(units = 2, activation='sigmoid'))

seqModel.build()
seqModel.summary()

from keras.losses import *
from keras.optimizers import *
from keras.metrics import *

lossFunc = SparseCategoricalCrossentropy()
batchSize = 1 #from 64 -> 32 for test
epochs = 10 # from 100 -> 10 for test
metrics=['mean_squared_error']
seqModel.compile(optimizer='nadam', loss=lossFunc, metrics=metrics)
seqModel.fit(x_train, y_train, validation_data=(x_test, y_test), epochs = epochs, batch_size = batchSize, validation_batch_size=batchSize)

print(x_train.shape) 
print(x_test.shape)
print(y_train.shape)
print(y_test.shape)

trainMod = seqModel.evaluate(x_train, y_train)
testMod = seqModel.evaluate(x_test, y_test)
print(trainMod)
print(testMod)

trainPred = seqModel.predict((x_train.reshape(-1,4)))
print(trainPred)
testPred = seqModel.predict((x_test.reshape(-1,4)))
print(testPred)

#jaycode
seqModel.save('sp.h5')
#@title jaycode
seqModel = load_model('sp.h5')

predictions = seqModel.predict(x_test)
predictions = sc.inverse_transform(predictions)
y_test_scaled = sc.inverse_transform(y_test.reshape(-1, 1))

fig, ax = plt.subplots(figsize=(16,8))
ax.set_facecolor('#000041')
ax.plot(y_test_scaled, color='red', label='Actual price')
plt.plot(predictions, color='cyan', label='Predicted price')
plt.legend()

trainMod = seqModel.evaluate(x_train, y_train)
testMod = seqModel.evaluate(x_test, y_test)
print(trainMod)
print(testMod)

trainPred = seqModel.predict((x_train.reshape(-1,4)))
print(trainPred)
testPred = seqModel.predict((x_test.reshape(-1,4)))
print(testPred)

